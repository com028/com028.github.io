<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一、基础知识在阅读源码前，我们先来熟悉一下相关的基础知识，这是理解runtime的基础。  用户级线程：由用户运行时(runtime)来管理线程，操作系统不能感知其存在，所以也不会对其调度，一般会在用户空间提供一个线程库来操作它们。在进程中多个用户级线程对应一个内核级线程，当内核线程阻塞，进程中的所有线程都会被阻塞。Lua的协程(coroutine)、golang的goroutine都属于用户级线">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang Runtime">
<meta property="og:url" content="http://yoursite.com/2020/06/01/golang/runtime/index.html">
<meta property="og:site_name" content="lifan&#39;s blog">
<meta property="og:description" content="一、基础知识在阅读源码前，我们先来熟悉一下相关的基础知识，这是理解runtime的基础。  用户级线程：由用户运行时(runtime)来管理线程，操作系统不能感知其存在，所以也不会对其调度，一般会在用户空间提供一个线程库来操作它们。在进程中多个用户级线程对应一个内核级线程，当内核线程阻塞，进程中的所有线程都会被阻塞。Lua的协程(coroutine)、golang的goroutine都属于用户级线">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-07-12T15:02:31.974Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang Runtime">
<meta name="twitter:description" content="一、基础知识在阅读源码前，我们先来熟悉一下相关的基础知识，这是理解runtime的基础。  用户级线程：由用户运行时(runtime)来管理线程，操作系统不能感知其存在，所以也不会对其调度，一般会在用户空间提供一个线程库来操作它们。在进程中多个用户级线程对应一个内核级线程，当内核线程阻塞，进程中的所有线程都会被阻塞。Lua的协程(coroutine)、golang的goroutine都属于用户级线">





  
  
  <link rel="canonical" href="http://yoursite.com/2020/06/01/golang/runtime/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Golang Runtime | lifan's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lifan's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-categories" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/golang/runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lifan's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Golang Runtime

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-06-01 22:54:06" itemprop="dateCreated datePublished" datetime="2020-06-01T22:54:06+08:00">2020-06-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h4><p>在阅读源码前，我们先来熟悉一下相关的基础知识，这是理解runtime的基础。</p>
<ul>
<li>用户级线程：由用户运行时(runtime)来管理线程，操作系统不能感知其存在，所以也不会对其调度，一般会在用户空间提供一个线程库来操作它们。在进程中多个用户级线程对应一个内核级线程，当内核线程阻塞，进程中的所有线程都会被阻塞。Lua的协程(coroutine)、golang的goroutine都属于用户级线程。</li>
<li>轻量级进程(LWP)：Linux中没有线程概念，跟线程比较相似的是轻量级进程(LWP)，一个进程中可以有多个LWT。LWP需要和内核线程绑定才能被执行，与内核线程是一对一的绑定关系。为了方便理解，我们直接把LWP看成是内核线程。</li>
<li>混合模型：进程中可以同时有多个内核线程和多个用户线程，用户线程只有绑定内核线程才能被执行，多个用户线程可以进入同一个内核线程的执行队列，由runtime负责用户线程的调度以及用户线程与内核线程的绑定与解绑。golang就是采用此模型。<a id="more"></a></li>
<li>OS调度：线程是内核调度的基本单位，在windows和linux上，可以通过CreateThread和clone创建线程(Linux clone创建的是LWP)，创建线程需要传递入口地址(通常是函数)，线程从这个入口地址开始执行。因为OS中的线程数量大部分时候是&gt;CPU核心数，OS为了确保每个线程都能得到公平的执行提出了时间片的概念,即每个线程只能持续执行一段时间，时间片到了后，保存上下文，切换到其它线程。上下文包含了2个重要的信息分别是PC和堆栈，记录它们可以确保线程被中断后，下次无论在哪个核上都能接着上次中断的现场继续执行。</li>
<li>CPU：CPU是真正的执行单位，线程是被CPU执行。在内核的调度下，符合条件的线程被CPU执行，正在被执行的其实是线程的局部指令，在这些局部指令可能是线程的某个函数片段或者协程。</li>
</ul>
<h4 id="二、GPM数据结构"><a href="#二、GPM数据结构" class="headerlink" title="二、GPM数据结构"></a>二、GPM数据结构</h4><p><code>golang runtime</code>是基于<code>GPM</code>模型来实现高并发的，它能充分发挥多核CPU的优势, 让每个核的负载更均衡。<code>GMP</code>在源码里对应了各自的结构体，这里只列出几个理解<code>runtime</code>必要的字段。</p>
<h5 id="1-1-G-goroutine"><a href="#1-1-G-goroutine" class="headerlink" title="1.1 G(goroutine)"></a>1.1 <code>G(goroutine)</code></h5><p><code>runtime</code>调度的基本单位。创建<code>goroutine</code>时会在函数前加go关键字，这个函数地址表示当前<code>goroutine</code>的入口地址。<code>goroutine</code>在执行过程中可能因为各种原因被暂停，这时需要保存PC和堆栈信息，以便恢复后时继续执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码文件 runtime/runtime2.go, runtime/proc.go, runtime/signal_unix.go, runtime/preempt.go</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    goid           <span class="keyword">int64</span>   <span class="comment">// goroutine id</span></span><br><span class="line">    atomicstatus   <span class="keyword">uint32</span>  <span class="comment">// 当前状态</span></span><br><span class="line">    stack          stack   <span class="comment">// g栈区间</span></span><br><span class="line">    sched          gobuf   <span class="comment">// 运行时信息，包含PC以及运行时的堆栈信息</span></span><br><span class="line">    stackguard0    <span class="keyword">uintptr</span> <span class="comment">// tackguard0 = stack.lo + StackGuard，如果要抢占当前g会把字段值设为stackPreempt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123; <span class="comment">//栈从高地址往低地址增长</span></span><br><span class="line">    lo <span class="keyword">uintptr</span></span><br><span class="line">    hi <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="keyword">uintptr</span></span><br><span class="line">    pc   <span class="keyword">uintptr</span></span><br><span class="line">    bp   <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>状态:每个<code>goroutine</code>都包含如下状态，当goroutine被创建后就在下面这些状态间切换。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_Gidle  <span class="comment">// 刚被创建，还没初始化</span></span><br><span class="line">_Grunnable <span class="comment">// 在运行队列中，还没被执行，也没分配栈 </span></span><br><span class="line">_Grunning <span class="comment">// 运行中</span></span><br><span class="line">_Gsyscall <span class="comment">// 系统调用</span></span><br><span class="line">_Gwaiting <span class="comment">// 阻塞状态，比如：等待channel、i/o操作被gopark</span></span><br><span class="line">_Gdead <span class="comment">// goroutine执行结束,进入freelist中</span></span><br><span class="line">_Gpreempted <span class="comment">// g被通过信号方式抢占</span></span><br></pre></td></tr></table></figure>

<h5 id="1-2-P-Processor"><a href="#1-2-P-Processor" class="headerlink" title="1.2 P(Processor)"></a>1.2 <code>P(Processor)</code></h5><p>逻辑处理器，从功能角度来看它更像是个资源管理器，主要包含了<code>goroutine</code>队列以及当前P的<a href="https://lifan.tech/2019/09/25/memory/golang-memory/" target="_blank" rel="noopener">内存分配信息</a>，创建<code>goroutine</code>时，首先偿试放入当前P的Local队列，如果队列已满，则把本地队列中的一半g转移到全局队列中。P必须和M绑定才能工作，一个P任意时刻只能绑定一个M，所以在P上分配内存，取队列中的<code>goroutine</code>都不需要加锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id          <span class="keyword">int32</span> <span class="comment">//P的id</span></span><br><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">//当前状态</span></span><br><span class="line">    mcache      *mcache <span class="comment">//内存分配器，之前的文章已经介绍过</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span> <span class="comment">//等执行的goroutine列表，访问时不需要加锁</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    m           muintptr <span class="comment">//P绑定的m</span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123; <span class="comment">//当G运行结束后，清除数据放入列表以便复用</span></span><br><span class="line">        gList</span><br><span class="line">        n <span class="keyword">int32</span></span><br><span class="line">    &#125;</span><br><span class="line">    runnext guintptr <span class="comment">//下个运行的g，如果不为nil, 则当前g执行完后，优先执行它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> P的状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_Pidle <span class="comment">//当M没有G可执行时，P进入空闲列表</span></span><br><span class="line">_Prunning <span class="comment">//P和M绑定，正在执行G或在寻找可执行的G</span></span><br><span class="line">_Psyscall <span class="comment">//与之关联中的M进入系统调用</span></span><br><span class="line">_Pgcstop <span class="comment">//GC STW</span></span><br><span class="line">_Pdead <span class="comment">//调小GOMAXPROCS数量后多余的p置为此状态</span></span><br></pre></td></tr></table></figure>

<h5 id="1-3-M-Machine"><a href="#1-3-M-Machine" class="headerlink" title="1.3 M(Machine)"></a>1.3 <code>M(Machine)</code></h5><p>系统线程抽象。M会从P的队列中取G来执行，当G被暂停M会把上下文信息写回G，并取下一个G继续执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    id            <span class="keyword">int64</span></span><br><span class="line">    g0      *g     <span class="comment">// 用于执行调度任务的g，使用系统栈，不受gc影响</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// 线程本地存储空间</span></span><br><span class="line">    curg          *g       <span class="comment">// 当前正在被执行的goroutine</span></span><br><span class="line">    nextp         puintptr <span class="comment">// M被唤醒需要立即绑定的P</span></span><br><span class="line">    p             puintptr <span class="comment">// 与M绑定的P</span></span><br><span class="line">    spinning      <span class="keyword">bool</span> <span class="comment">// true表示M处于自旋转状态(当前没有g执行，正在寻找可执行的g)</span></span><br><span class="line">    mcache        *mcache <span class="comment">//当M与P绑定后，跟P的mcache指向同一个内存分配器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、调度流程"><a href="#三、调度流程" class="headerlink" title="三、调度流程"></a>三、调度流程</h4><h5 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h5><ul>
<li><code>M0</code>：进程的主线程，启动进程时默认启动M0。</li>
<li><code>G0</code>：每个M创建的第一个g用于g的调度，创建M时为<code>g0</code>分配固定栈空间不走普通<code>g0</code>的栈扩张流程，<code>g0</code>不受<code>GC</code>影响，主要工作包括：<code>GC、netpoll、goroutine</code>的创建等。</li>
<li>自旋转：进入调度流程后<code>findrunable</code>函数会一直寻找可执行的g(本地队列，全局队列，<code>netpoll</code>)，如果处于自旋转状态，还会偿试去其它p的队列中偷g，直到找到为止。当自旋转中的m数量 &lt; runing中p数量的1/2时，才会有m进入自旋转，这样保证了新到的g能够快速被执行，也确保了<code>runtime</code>中不会同时存在大量不必要自旋转的M消耗<code>cpu</code>。</li>
</ul>
<h5 id="1-2-主要流程"><a href="#1-2-主要流程" class="headerlink" title="1.2 主要流程"></a>1.2 主要流程</h5><ul>
<li>当启动<code>m0</code>时，会创建<code>GOMAXPROCS</code>个p, 状态置为<code>_Pidle</code>。</li>
<li>用<code>go</code>关键字创建协程时，首先偿试把g放入P本地队列，如果本地队列已满，则把本地队列中的g迁移一半到全局队列。并检查如果存在<code>idle</code>的P且没有M处于自旋转，则获取一个<code>idle</code>的P跟<code>idle</code>的M绑定，如果没有<code>idle</code>的M，则新建一个M，并让M进入自旋转。g运行结束后<code>g0</code>会调用<code>schedue</code>继续寻找可执行的g。</li>
<li>schedue调用findrunable函数寻找可执行的g，首先从p的本地队列(runq)中寻找可执行(状态为_Grunnable)g；如果没找到则从全局队列中寻找，若全局队列中有则拿一批(<code>sched.runqsize/gomaxprocs + 1</code>个，最多拿一半)到本地队列；如果全局队列也没有，则查看netpoll中是否有阻塞的g，如果有则检查epoll是否有fd就绪，有则寻找成功，把这些g的状态从_Grunnable改为_Grunning，并把多余的g放入全局队列；如果netpoll中也没有，则从其它p中偷。</li>
<li>g的调度没有时间片概念，<code>sysmon</code>或<code>gc</code>抢占g做法是把<code>stackguard0</code>置<code>stackPreempt</code>，当g调用函数触发<code>newstack</code>时根据<code>stackPreempt</code>标记抢占。在<code>golang1.14</code>以前如果g中没有函数调用，比如是一个纯数值计算的<code>for</code>循环，那g永远也不会被抢占，当然<code>gc</code>也无法成功执行。</li>
</ul>
<h4 id="四、Runtime源码"><a href="#四、Runtime源码" class="headerlink" title="四、Runtime源码"></a>四、Runtime源码</h4><h5 id="1-1-main函数启动"><a href="#1-1-main函数启动" class="headerlink" title="1.1 main函数启动"></a>1.1 main函数启动</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. osinit 初始化cpu数量和页大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">osinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ncpu = getproccount()</span><br><span class="line">    physHugePageSize = getHugePageSize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. call schedinit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sched.maxmcount = <span class="number">10000</span> <span class="comment">//m的最大数量</span></span><br><span class="line">    mallocinit() <span class="comment">//内存分配相关</span></span><br><span class="line">    <span class="comment">//根据环境变量，创建GOMAXPROCS个G</span></span><br><span class="line">    sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 启动 main goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g := getg()</span><br><span class="line">    <span class="comment">// 标记main已经启动</span></span><br><span class="line">    mainStarted = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//在系统栈上创建m，并执行sysmon</span></span><br><span class="line">    <span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123;</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果main goroutine不在m0上运行，肯定bug了</span></span><br><span class="line">    <span class="keyword">if</span> g.m != &amp;m0 &#123;</span><br><span class="line">        throw(<span class="string">"runtime.main not on m0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行runtime的init和用户包中init函数</span></span><br><span class="line">    doInit(&amp;runtime_inittask)</span><br><span class="line">    doInit(&amp;main_inittask)</span><br><span class="line">    <span class="comment">//调用用户自定义的main函数</span></span><br><span class="line">    <span class="comment">//从这里可以看出在golang中，init函数先于main函数执行</span></span><br><span class="line">    fn := main_main</span><br><span class="line">    fn()</span><br><span class="line">    <span class="comment">//退出主进程</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x *<span class="keyword">int32</span></span><br><span class="line">        *x = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4. call runtime·mstart</span></span><br><span class="line"><span class="comment">//M0在这里调用的https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s#L225</span></span><br><span class="line"><span class="comment">// mstart 是一个新M的入口函数.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> osStack &#123;</span><br><span class="line">        <span class="comment">// 初始化g0栈大小</span></span><br><span class="line">        size := _g_.stack.hi</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">        &#125;</span><br><span class="line">        _g_.stack.hi = <span class="keyword">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">        _g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">    _g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">    _g_.stackguard1 = _g_.stackguard0</span><br><span class="line">    mstart1()</span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">"windows"</span> || GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"illumos"</span> || GOOS == <span class="string">"plan9"</span> || GOOS == <span class="string">"darwin"</span> || GOOS == <span class="string">"aix"</span> &#123;</span><br><span class="line">        osStack = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m退出</span></span><br><span class="line">    mexit(osStack)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="keyword">if</span> _g_ != _g_.m.g0 &#123;<span class="comment">//调用这个函数只，m上只可能有g0</span></span><br><span class="line">        throw(<span class="string">"bad runtime·mstart"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化m</span></span><br><span class="line">    asminit()</span><br><span class="line">    minit()</span><br><span class="line">    <span class="comment">//执行mspinning、sysmon等</span></span><br><span class="line">    <span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_g_所在的m不是m0,则关联p和m</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">        acquirep(_g_.m.nextp.ptr())</span><br><span class="line">        _g_.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    schedule()<span class="comment">//开始调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-创建协程"><a href="#1-2-创建协程" class="headerlink" title="1.2 创建协程"></a>1.2 创建协程</h5><p>在函数前加go关键字创建一个协程，其实是调用<code>newproc</code>函数，fn就是go关键字后面函数地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//在系统堆栈上执行newproc1</span></span><br><span class="line">        newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">        _g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">        throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    acquirem()</span><br><span class="line">    siz := narg</span><br><span class="line">    siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    newg := gfget(_p_) <span class="comment">//从p的gFree中获取一个g(g运行结束后，会清理数据，放入p的gFree队列中以便复用)</span></span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">        newg = malg(_StackMin) <span class="comment">//new一个栈大小为2k的g，并把状态设为_Gdead</span></span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">        allgadd(newg) <span class="comment">//把g加入到allgs列表，因为状态为Gdead，所以GC不会扫描</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算参数栈的起始位置</span></span><br><span class="line">    totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize</span><br><span class="line">    totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  </span><br><span class="line">    sp := newg.stack.hi - totalSize</span><br><span class="line">    spArg := sp</span><br><span class="line">    <span class="keyword">if</span> usesLR &#123;</span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">        prepGoExitFrame(sp)</span><br><span class="line">        spArg += sys.MinFrameSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123; <span class="comment">//把参数拷贝到g的栈上</span></span><br><span class="line">        memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清理运行时信息(g.sched)</span></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">    <span class="comment">//g成员初始值，</span></span><br><span class="line">    newg.sched.sp = sp</span><br><span class="line">    newg.stktopsp = sp</span><br><span class="line">    <span class="comment">//设置g的退出函数为goexit，g结束后m会调用goexit清理g，并重新调用schedule</span></span><br><span class="line">    newg.sched.pc = funcPC(goexit) + sys.PCQuantum </span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">    newg.gopc = callerpc</span><br><span class="line">    newg.ancestors = saveAncestors(callergp)</span><br><span class="line">    newg.startpc = fn.fn</span><br><span class="line">    <span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">        newg.labels = _g_.m.curg.labels</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">        atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//g状态改为 _Grunnable</span></span><br><span class="line">    casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line">    newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">    _p_.goidcache++</span><br><span class="line">    <span class="comment">//runqput会优先放入p本地队列，如果本地队列已满，则把本地队列挪一半到全局队列</span></span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">//如果有p处于idle状态、没有m处于自旋转、主线程已启动则偿试唤醒一个p</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-调度流程"><a href="#1-3-调度流程" class="headerlink" title="1.3 调度流程"></a>1.3 调度流程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得并执行goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg() <span class="comment">//获取当前g</span></span><br><span class="line">    <span class="keyword">var</span> gp *g</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 为了保证公平调度，schedule每执行61次就会去全局队列拿一批g到地址队列</span></span><br><span class="line">        <span class="comment">// 否则可能出现2个g永久占用本地队列(因为被暂停的goroutine唤醒后优先放入本地队列)</span></span><br><span class="line">        <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//从本地队列中取g</span></span><br><span class="line">        gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果本地队列中没有可执行的g，则调用findrunnable直到有可运行的g为止</span></span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">        gp, inheritTime = findrunnable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里，说明已经找到可运行的g，如果m还处于自旋转状态，则置回正常状态</span></span><br><span class="line">    <span class="comment">// 并唤醒p与之绑定</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">        resetspinning()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接在当前m上执行g</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞获取可执行的G，findrunnable会从全局队列、其它P队列、netpoll中去轮询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// 本地队列中有g，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局队列中如果有g,则从全局队列中取一批到本地队列</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从netpoll中获取g(非阻塞轮询已经完成的网络io)</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123;<span class="comment">//从netpoll中取出i/o读写完成的g列表</span></span><br><span class="line">            gp := list.pop()<span class="comment">//先取出一个让当前m执行,这样能提高响应速度</span></span><br><span class="line">            injectglist(&amp;list)<span class="comment">//再把剩余的g列表放入队列</span></span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否可以从其它p中偷一部分g</span></span><br><span class="line">    procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">//如果其它p全部都是idle的，那肯定没地方偷</span></span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前m没有处于自旋转且自旋转中的m数量 &lt; running数量/2,则让当前m进入自旋转</span></span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">goto</span> stop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">        atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机从一个p中偷，最多偿试4次</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">            <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            stealRunNextG := i &gt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">stop:</span><br><span class="line">    allpSnapshot := allp</span><br><span class="line">    <span class="comment">//再次检查全局队列，如果有g，则取出执行，否则把p与当前m解绑</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> releasep() != _p_ &#123; <span class="comment">//p与当前m解绑</span></span><br><span class="line">        throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    pidleput(_p_) <span class="comment">//解绑的p放入idle队列</span></span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    wasSpinning := _g_.m.spinning</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;<span class="comment">//如果当前m还处于自旋转状态，则取消，sched.nmspinning -1</span></span><br><span class="line">        _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查所有p的队列</span></span><br><span class="line">    <span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">        <span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget() <span class="comment">//如果某个p的队列不为空，则从idle列表中取出一个p</span></span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                <span class="keyword">if</span> wasSpinning &#123;<span class="comment">//如果解绑以前m是自旋转的，则还是让它保持自旋转</span></span><br><span class="line">                    _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">                    atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> top</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次从netpoll中阻塞的取g</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">            throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        list := netpoll(<span class="literal">true</span>) </span><br><span class="line">        atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">        <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">            lock(&amp;sched.lock)</span><br><span class="line">            _p_ = pidleget()</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">                acquirep(_p_)</span><br><span class="line">                gp := list.pop()</span><br><span class="line">                injectglist(&amp;list)</span><br><span class="line">                casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                    traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果始终找到不，就让m停止</span></span><br><span class="line">    stopm()</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把g列表放入全局队列，调用startm检测是否有idle的p，将idle的m与之绑定或new一个m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">injectglist</span><span class="params">(glist *gList)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> glist.empty() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        <span class="keyword">for</span> gp := glist.head.ptr(); gp != <span class="literal">nil</span>; gp = gp.schedlink.ptr() &#123;</span><br><span class="line">            traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span>; !glist.empty(); n++ &#123;</span><br><span class="line">        gp := glist.pop()</span><br><span class="line">        <span class="comment">//队列中的g状态必须为_Grunnable</span></span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">        globrunqput(gp)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">for</span> ; n != <span class="number">0</span> &amp;&amp; sched.npidle != <span class="number">0</span>; n-- &#123;</span><br><span class="line">        startm(<span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    *glist = gList&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重置自旋转状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetspinning</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">        throw(<span class="string">"resetspinning: not a spinning m"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">    nmspinning := atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">int32</span>(nmspinning) &lt; <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有其它m处于自旋转状态，但还有p处于idle，则唤醒p(这样能提高g的处理速度)</span></span><br><span class="line">    <span class="keyword">if</span> nmspinning == <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        wakep()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果有m处于自旋转状态，则直接返回(g一定会被处于自旋转状态的m执行[结合findrunable函数看])</span></span><br><span class="line">    <span class="keyword">if</span> !atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//startm检测是否有idle的p,并将idle的m与p绑定或new一个m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">        _p_ = pidleget()<span class="comment">//获取一个idle的p</span></span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            unlock(&amp;sched.lock)</span><br><span class="line">            <span class="keyword">if</span> spinning &#123;</span><br><span class="line">                <span class="comment">// spinning为true说明startm的调用方对nmspinning加了1，但是没发现idle的p，所以要回滚nmspinning</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">"startm: negative nmspinning"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功获取到p, 再获取idle的m</span></span><br><span class="line">    mp := mget()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;<span class="comment">//获取idle的m失败，则创建一个m</span></span><br><span class="line">        <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="title">spinning</span></span> &#123;</span><br><span class="line">            <span class="comment">// 如果spinning为true, 则标记新创建的m为spinning</span></span><br><span class="line">            fn = mspinning</span><br><span class="line">        &#125;</span><br><span class="line">        newm(fn, _p_)<span class="comment">//创建新m</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    mp.spinning = spinning</span><br><span class="line">    mp.nextp.set(_p_)  <span class="comment">// 把p设置为即将与m绑定的p</span></span><br><span class="line">    notewakeup(&amp;mp.park)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">    mp := allocm(_p_, fn) <span class="comment">//new一个m结构，并初始化</span></span><br><span class="line">    mp.nextp.set(_p_)<span class="comment">//把p设置为即将与m绑定的p</span></span><br><span class="line">    mp.sigmask = initSigmask</span><br><span class="line">    newm1(mp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    execLock.rlock()</span><br><span class="line">    newosproc(mp)</span><br><span class="line">    execLock.runlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//newosproc创建OS线程，不同的OS接口不一样，linux用的clone, windows为_CreateThread</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">    <span class="comment">// clone期间禁用信号，clone完成再启用</span></span><br><span class="line">    <span class="keyword">var</span> oset sigset</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">    <span class="comment">//调用clone创建os线程， mstart为线程起始函数</span></span><br><span class="line">    ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-sysmon"><a href="#1-4-sysmon" class="headerlink" title="1.4 sysmon"></a>1.4 sysmon</h5><p><code>sysmon</code>监控整个<code>runtime</code>，它的任务包括触发<code>gc、netpool</code>、暂停运行时间过长的<code>goroutine</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">    idle := <span class="number">0</span> </span><br><span class="line">    delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// start with 20us sleep...</span></span><br><span class="line">            delay = <span class="number">20</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">            delay *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// up to 10ms</span></span><br><span class="line">            delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">        usleep(delay)<span class="comment">//sysmon每个周期会睡眠20us~10ms</span></span><br><span class="line">        <span class="comment">// 每10nm检查一次网络io中是否有准备好的g, 并把它们放入全局队列中</span></span><br><span class="line">        lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">        now := nanotime()</span><br><span class="line">        <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">            atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">            list := netpoll(<span class="literal">false</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">            <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">                incidlelocked(<span class="number">-1</span>)</span><br><span class="line">                injectglist(&amp;list)</span><br><span class="line">                incidlelocked(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 抢占阻塞在系统调用中的p和长时间运行的g</span></span><br><span class="line">        <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">            idle = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            idle++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="keyword">int64</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        s := _p_.status</span><br><span class="line">        sysretake := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// 如果g运行时间太长(10ms)，则抢占</span></span><br><span class="line">            t := <span class="keyword">int64</span>(_p_.schedtick)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">                pd.schedtick = <span class="keyword">uint32</span>(t)</span><br><span class="line">                pd.schedwhen = now</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">                preemptone(_p_)<span class="comment">//告诉_p_的当前g停止运行</span></span><br><span class="line">                sysretake = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// 抢占阻塞在系统调用上的p，如果阻塞时间超过1个sysmon tick周期，则抢占</span></span><br><span class="line">            t := <span class="keyword">int64</span>(_p_.syscalltick)</span><br><span class="line">            <span class="keyword">if</span> !sysretake &amp;&amp; <span class="keyword">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">                pd.syscalltick = <span class="keyword">uint32</span>(t)</span><br><span class="line">                pd.syscallwhen = now</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一方面，如果没有其它的g可以执行，我们不希望抢占p</span></span><br><span class="line">            <span class="comment">//另一方面，因为抢占能阻止sysmon线程进入深度睡眠，我们还是希望抢占它</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="五、基于信号抢占调度"><a href="#五、基于信号抢占调度" class="headerlink" title="五、基于信号抢占调度"></a>五、基于信号抢占调度</h4><p><code>golang1.14</code>以前采用的是基于协作式抢占调度，抢占g时把<code>stackguard0</code>设置为<code>stackPreempt</code>。在<code>goroutine</code>中调用函数时触发<code>newstack</code>并检测<code>stackPreempt</code>标记以实现抢占。假如g1是一个长时间纯数值计算的协程或无函数调用的<code>for</code>循环，在这期间，g1不会被抢占。如果此时触发了gc, 整个进程除了g1以外，其它<code>goroutine</code>都被gc停止, 直到g1执行完成。<br><code>golang1.14</code>加入了基于信号抢占调度，通过向g所在的M发送信号来实现抢占，这可以避免g中无函数调用时不能抢占成功的情况，这对于gc来说尤其重要。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mp := _p_.m.ptr()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 请求异步抢占m的当前g，不是所有os都支持信号抢占，这里通过preemptMSupported标识</span></span><br><span class="line">    <span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">        _p_.preempt = <span class="literal">true</span></span><br><span class="line">        preemptM(mp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptM</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !pushCallSupported &#123;</span><br><span class="line">        <span class="comment">//如果当前架构不支持ctxt.pushCall，那么doSigPreempt也不可能被调用</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> atomic.Cas(&amp;mp.signalPending, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//确保多线程调用只有一个能成功</span></span><br><span class="line">        <span class="comment">//发送信号</span></span><br><span class="line">        signalM(mp, sigPreempt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收到信号时，OS会回调此函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sighandler</span><span class="params">(sig <span class="keyword">uint32</span>, info *siginfo, ctxt unsafe.Pointer, gp *g)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sig == sigPreempt &#123;</span><br><span class="line">        <span class="comment">// 如果是抢占信号</span></span><br><span class="line">        doSigPreempt(gp, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSigPreempt</span><span class="params">(gp *g, ctxt *sigctxt)</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果要抢占、检测是否安全</span></span><br><span class="line">    <span class="keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) &#123;</span><br><span class="line">        <span class="comment">//asyncPreempt会保存保存上下文，调用asyncPreempt2后，再恢复上下文</span></span><br><span class="line">        ctxt.pushCall(funcPC(asyncPreempt))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录抢占</span></span><br><span class="line">    atomic.Xadd(&amp;gp.m.preemptGen, <span class="number">1</span>)</span><br><span class="line">    atomic.Store(&amp;gp.m.signalPending, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncPreempt2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    gp.asyncSafePoint = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">        mcall(preemptPark)<span class="comment">//切换到g0栈执行暂停任务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mcall(gopreempt_m)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.asyncSafePoint = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暂停gp并置为_Gpreempted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptPark</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoPark(traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    status := readgstatus(gp)</span><br><span class="line">    <span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">        dumpgstatus(gp)</span><br><span class="line">        throw(<span class="string">"bad g status"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waitreason = waitReasonPreempted</span><br><span class="line">    <span class="comment">//在dropg之前不能是runing状态</span></span><br><span class="line">    casGToPreemptScan(gp, _Grunning, _Gscan|_Gpreempted)</span><br><span class="line">    dropg()<span class="comment">//g与m解绑，g被暂停</span></span><br><span class="line">    casfrom_Gscanstatus(gp, _Gscan|_Gpreempted, _Gpreempted)</span><br><span class="line">    schedule()<span class="comment">//重新进入调度流程为m寻找可执行的g</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考<br><a href="https://mp.weixin.qq.com/s/gTb9p0WpJ37M5_k9e6xUiQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gTb9p0WpJ37M5_k9e6xUiQ</a><br><a href="https://wudaijun.com/2018/01/go-scheduler/" target="_blank" rel="noopener">https://wudaijun.com/2018/01/go-scheduler/</a><br><a href="https://zboya.github.io/post/go_scheduler/" target="_blank" rel="noopener">https://zboya.github.io/post/go_scheduler/</a><br><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</a><br><a href="https://changkun.de/golang/zh-cn/part2runtime/ch06sched/" target="_blank" rel="noopener">https://changkun.de/golang/zh-cn/part2runtime/ch06sched/</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/08/game/game-ranking/" rel="next" title="游戏中的排行榜">
                <i class="fa fa-chevron-left"></i> 游戏中的排行榜
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/03/golang/netpoll/" rel="prev" title="Golang Netpoll 实现原理">
                Golang Netpoll 实现原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、基础知识"><span class="nav-text">一、基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、GPM数据结构"><span class="nav-text">二、GPM数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-G-goroutine"><span class="nav-text">1.1 G(goroutine)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-P-Processor"><span class="nav-text">1.2 P(Processor)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-M-Machine"><span class="nav-text">1.3 M(Machine)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、调度流程"><span class="nav-text">三、调度流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-相关概念"><span class="nav-text">1.1 相关概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-主要流程"><span class="nav-text">1.2 主要流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、Runtime源码"><span class="nav-text">四、Runtime源码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-main函数启动"><span class="nav-text">1.1 main函数启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-创建协程"><span class="nav-text">1.2 创建协程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-调度流程"><span class="nav-text">1.3 调度流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-sysmon"><span class="nav-text">1.4 sysmon</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、基于信号抢占调度"><span class="nav-text">五、基于信号抢占调度</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
